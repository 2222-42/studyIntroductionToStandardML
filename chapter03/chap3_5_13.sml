(* SML source file. Copyright (c) by 2222-42 2020.
* Q 3.13
*)

(* 1 *)
fn x => x 1;
(* 
expect: 関数式だから、値式である
*)

(* 2 *)
(fn x => x) 1
(* 
expect: 関数式に対して値の代入を実行しているから、値式ではない
*)

(* 3 *)
(fn x => x, fn x => x)
(* 
expect: 関数式のタプルだから、値式である
*)

(* 4 *)
let fun f x = x in f end;
(* 
expect: fにfun f x = xを代入しているから、値式ではない。

筆者の補足：
ランク１多相性を実現しているSML#では以下のように多相型が与えられる．
# let val a = 1 + 1 in fn x => x end;
val it = fn : ['a .'a  -> 'a]
*)

(* 5 *)
let val a = 1 + 1 in fn x => x end;
(* 
expect: fn x => xにaを代入しているから、値式ではない。

筆者の補足：
ランク１多相性を実現しているSML#では以下のように多相型が与えられる．
# let val a = 1 + 1 in fn x => x end;
val it = fn : ['a .'a  -> 'a]
*)

(* 疑問：筆者の補足に含まれるランク1多相性ってなんぞ。 *)
(* 
ref: https://www.pllab.riec.tohoku.ac.jp/smlsharp/ja/?Foundations%2F020

ランク1多相性は，言わば，

- より柔軟な多相型システム
- MLの値多相性制約
- 効率よい型主導コンパイル

をともに実現するための"妥協の産物"と言える．

ランク１多相性を含む型システムの目的の一つは，この値多相性の制約下でも，makeObjのような高階の関数の返す値に対しても多相型を許すことである．

値多相性制約は，値式ではない(中略)式に対しては多相型は与えられない，という制約である。
ここで，「多相型は与える」とは，この式の型を推論した結果えられる型の中の型変数を多相型に昇格させる操作である．
*)
(* よくわからないから、本書が読み終わったら勉強しよう *)
