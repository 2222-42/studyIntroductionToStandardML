
Q 3.9

- `exp_t`: `t`

- `exp`: `a` (`a` は `t` より一般的な多相型)

3.9.1　`exp`の式の動作を変えずに、その式の型を`t`に制限する式の定義

> `if true then exp else exp_t`

3.9.2 恒等関数と同じ動作をし、かつ型が`t -> t`である関数を定義せよ

> `fun id x = (if true then x else exp_t);`

筆者の回答：

3.9.1

> 式expの型を式Eτの型と強制的に一致させるには，それら二つの式を，それらの型が等式で結ばれるような式の中に埋め込めばよい
> `(fn y => fn z => z (y exp_τ) (y exp))`
> この関数はexpと同一の動作をせず，要求を満さない
> 求める式は，評価するとexpが得られるような式でなければならない．そこで，上記のexpの部分を引数とし，
> ` (fn x => ...  (fn y =>fn z => z (y Eτ) (y exp)) ... ) exp`
> と変形することを考える．
> 関数の本体全体はxと同一の意味をもつ式である必要がある．そこで，val K = fn x => fn y => xを使い，型を一致させるだけに導入した上記の部分を捨て，exp自身を返すようにすればよい
> ` (fn x => K x (fn y =>fn z => z (y Eτ) (y exp))) exp`

3.9.2

> ` fn x => K x (fn y =>fn z => z (y Eτ) (y x))`
