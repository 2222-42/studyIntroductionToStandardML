
# 循環2重リンクリスト

# 循環2重リンクリストの前準備

## 参照型について

MLの変数は、その変数に束縛された値を表す式である。
そのため、変数の値を「更新する」といった概念はない。
処理するデータ構造によっては、共有変数の更新ができると、効率よいプログラムが書ける場合が多い。
この目的のために、特殊なデータ型である `ref` 型構成子が用意されている。

`t ref`型: 
- `t`型のデータへのポイント
- MLではこの型を`t`の参照型と呼ぶ
- `t`の型に関わらず、同一のポイントか否かの等値性テストが可能な`eqtype`である

```sml
infix 3 :=
val ref : 'a -> 'a ref
    (* 型構成子でありながら、ref型データのデータ構成子でもある *)
val ! : 'a ref -> 'a
    (* 値を取り出す *)
val := : 'a ref * 'a -> unit
    (* 参照型データの値を更新する演算子 *)
```

### 評価順序とそのための構文

式の評価順序: 
- 値の定義構文、`let ... in exp end`では、順々に評価
- 組やレコード式などの同一レベルの式が並んでいる場合は、左から順に評価
   - レコード式の評価の結果はラベルによってソートされるが、評価順序は表記された式の順序
- 関数適用(`exp1 exp2`)の評価は、
   1. `exp1`を評価し、
   2. 関数式`fn x => exp0`を得、
   3. `exp2`を評価し、値vを得
   4. 最後に`x`を`v`に束縛し、`exp0`を評価する

評価順序の制御のための構文: 
- `(exp1; ...; expn)`
  - `exp1`から`expn`をこの順に評価し、 `expn`の値をこの式全体の値とする
- `exp1 before exp2`
  - `exp1`, `exp2`の順で評価し、`exp1`をこの式全体の値とする
  - ただし、`exp2`は`unit`型の式でなければならない
    - `before`だから
- `while exp1 do exp2`
  - `bool`型を持つ`exp1`の評価結果が`false`になるまで、`exp1`と`exp2`をこの順に繰り返し評価
  - 結果は常に`()`である

以下の式の評価の結果を予測せよ。

```sml
(fn f => (print "a\n"; f))
(fn x => (print "b\n"; x))
(print "c\n"; 1);
```

```sml
(fn f => (print "a\n"; f))
(
    (fn x => (print "b\n"; x))
    (print "c\n"; 1)
);
```

# 循環2重リンクリスト

## 循環2重リンクリストの説明

通常のリストは、先頭要素の取り出しおよび要素を順に処理するのに適したデータ構造である。

循環2重リンクリストは、リストを逆方向にたどったり、リストの中間要素を取り除くといった操作を効率的に行える柔軟なリスト構造である。

実際、リスト全体を反復処理するケースでは、循環2重リンクリストの循環性が柔軟性を提供してくれる。(cf: [Linuxカーネルが循環的な二重リンクリストを使用してプロセスのリストを格納するのはなぜですか?](https://jpcodeqa.com/q/e0e9ed377dc908012d58df7b14dbc857))

## SMLでの定義と種々の関数の実装

```sml
(* 参照型とデータ型定義を組み合わせて循環2重リンクリストを作る *)
datatype 'a cell = NIL | CELL of {data: 'a, left: 'a cell ref, right: 'a cell ref}
type 'a dlist = 'a cell ref;
```

通常のリストと異なり、後続(`right`)のcellへの参照だけではなく、前方(`left`)への参照がある。特に、末尾のcellは先頭のcellへの参照を持ち、また、先頭のcellは末尾のcellへの参照を持っている。

```smi
dataDlist : 'a dlist -> 'a (* 先頭のデータを取り出す *)
rightDlist : 'a dlist -> 'a dlist (*ポインタを右にたどる*)
leftDlist : 'a dlist -> 'a dlist (*ポインタを左にたどる*)
insertDlist : 'a -> 'a dlist -> unit (*要素を追加する*)
singleDlist : 'a -> 'a dlist (*要素1つの循環2重リンクリストを作る*)
deleteDlist : 'a dlist -> unit (*先頭要素を削除する*)
fromListToDlist : 'a list -> 'a dlist (*リストを循環2重リンクリストに変換する*)
```

以下の実装を見て、循環2重リンクリストの理解を深めよう。

```smi
val concatDlist : 'a dlist -> 'a dlist -> unit (* 循環2重リンクリストを連結する関数 *)
```

循環2重リンクリストは、通常のリストのように空になるまで再帰的に処理を行うといったプログラミはかけない。そのため、処理を行ったセルを記録し、すでに処理済みのセルが見つかるまで処理を行うようなコードを書かなければならない。

```smi
val dlistToList : 'a list -> 'a dlist
```

適切な定義のためには、以下の2つが必要である。

- 循環構造を辿る際の終了条件の適切な判定
- `left`および`right`フィールドをたどると自分自身に戻ってくる CELLへの参照型データの作成

## 長所と短所

GeeksforGeeksの記事から引用し、翻訳する[Doubly Circular Linked List | Set 1 (Introduction and Insertion)](https://www.geeksforgeeks.org/doubly-circular-linked-list-set-1-introduction-and-insertion/)


### 長所

- このリストは、両方向、つまり、先頭から末尾へ、末尾から先頭へとトラバースできる。
- 先頭から末尾へ、また、末尾から先頭への移動が、定数時間`O(1)`で済む。
- 循環2重リンクリストは、フィボナッチヒープなどの高度なデータ構造の実装にも使われている。

(フィボナッチヒープについては知らないので調べる)

### 短所

- それぞれのノードが前のポインタを収容するために、わずかながら追加のメモリを要する。
- リストの実装や操作において、多くのポインタが関与する。そのため、ポインタは注意深く扱われねばならない。さもなくば、そのリストのデータは失われる。

