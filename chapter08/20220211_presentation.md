
# 循環2重リンクリスト

## 参照型について

MLの変数は、その変数に束縛された値を表す式である。
そのため、変数の値を「更新する」といった概念はない。
処理するデータ構造によっては、共有変数の更新ができると、効率よいプログラムが書ける場合が多い。
この目的のために、特殊なデータ型である `ref` 型構成子が用意されている。

`t ref`型: 
- `t`型のデータへのポイント
- MLではこの型を`t`の参照型と呼ぶ
- `t`の型に関わらず、同一のポイントか否かの等値性テストが可能な`eqtype`である

```sml
infix 3 :=
val ref : 'a -> 'a ref
    (* 型構成子でありながら、ref型データのデータ構成子でもある *)
val ! : 'a ref -> 'a
    (* 値を取り出す *)
val := : 'a ref * 'a -> unit
    (* 参照型データの値を更新する演算子 *)
```

### 評価順序とそのための構文

式の評価順序: 
- 値の定義構文、`let ... in exp end`では、順々に評価
- 組やレコード式などの同一レベルの式が並んでいる場合は、左から順に評価
   - レコード式の評価の結果はラベルによってソートされるが、評価順序は表記された式の順序
- 関数適用(`exp1 exp2`)の評価は、
   1. `exp1`を評価し、
   2. 関数式`fn x => exp0`を得、
   3. `exp2`を評価し、値vを得
   4. 最後に`x`を`v`に束縛し、`exp0`を評価する

評価順序の制御のための構文: 
- `(exp1; ...; expn)`
  - `exp1`から`expn`をこの順に評価し、 `expn`の値をこの式全体の値とする
- `exp1 before exp2`
  - `exp1`, `exp2`の順で評価し、`exp1`をこの式全体の値とする
  - ただし、`exp2`は`unit`型の式でなければならない
    - `before`だから
- `while exp1 do exp2`
  - `bool`型を持つ`exp1`の評価結果が`false`になるまで、`exp1`と`exp2`をこの順に繰り返し評価
  - 結果は常に`()`である

以下の式の評価の結果を予測せよ。

```sml
(fn f => (print "a\n"; f))
(fn x => (print "b\n"; x))
(print "c\n"; 1);
```

```sml
(fn f => (print "a\n"; f))
(
    (fn x => (print "b\n"; x))
    (print "c\n"; 1)
);
```

## 循環2重リンクリスト

通常のリストは、戦闘要素の取り出しおよび要素を順に処理するのに適したデータ構造である。

循環2重リンクリストは、リストを逆方向にたどったり、リストの中間要素を取り除くといった操作を効率的に行える柔軟なリスト構造である。

```sml
(* 参照型とデータ型定義を組み合わせて循環2重リンクリストを作るよ *)
datatype 'a cell = NIL | CELL of {data: 'a, left: 'a cell ref, right: 'a cell ref}
type 'a dlist = 'a cell ref;
```

```smi
dataDlist : 'a dlist -> 'a (* 先頭のデータを取り出す *)
rightDlist : 'a dlist -> 'a dlist (*ポインタを右にたどる*)
leftDlist : 'a dlist -> 'a dlist (*ポインタを左にたどる*)
insertDlist : 'a -> 'a dlist -> unit (*要素を追加する*)
singleDlist : 'a -> 'a dlist (*要素1つの循環2重リンクリストを作る*)
deleteDlist : 'a dlist -> unit (*先頭要素を削除する*)
fromListToDlist : 'a list -> 'a dlist (*リストを循環2重リンクリストに変換する*)
```
